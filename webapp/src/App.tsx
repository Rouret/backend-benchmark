//GENERATED BY IA
import { useState, useMemo } from "react";
import results from "./result.json";
import "./App.css";

interface Metrics {
  latency: number;
  requestsPerSecond: number;
  bytesPerSecond: number;
}

interface TestCase {
  runCommand: string;
  basePath: string;
  name: string;
  url: string;
}

interface Result {
  testCase: TestCase;
  metrics: Metrics;
  category: string;
}

type SortMetric = "requestsPerSecond" | "latency" | "bytesPerSecond";

function App() {
  const [activeCategory, setActiveCategory] = useState<string | null>(null);
  const [sortBy, setSortBy] = useState<SortMetric>("requestsPerSecond");
  const [selectedFramework, setSelectedFramework] = useState<string | null>(
    null
  );

  const categories = useMemo(() => {
    const uniqueCategories = new Set<string>();
    (results as Result[]).forEach((result) => {
      uniqueCategories.add(result.category);
    });
    return Array.from(uniqueCategories);
  }, []);

  // If no category is selected, use the first one
  const currentCategory = activeCategory || categories[0];

  const filteredResults = useMemo(() => {
    // Filter by category then sort according to the selected metric
    return (results as Result[])
      .filter((result) => result.category === currentCategory)
      .sort((a, b) => {
        if (sortBy === "latency") {
          // For latency, lower is better
          return a.metrics.latency - b.metrics.latency;
        } else if (sortBy === "requestsPerSecond") {
          // For requests/sec, higher is better
          return b.metrics.requestsPerSecond - a.metrics.requestsPerSecond;
        } else {
          // For bytes/sec, higher is better
          return b.metrics.bytesPerSecond - a.metrics.bytesPerSecond;
        }
      });
  }, [currentCategory, sortBy]);

  // Calculate rankings for each metric
  const rankings = useMemo(() => {
    const latencyRank = [...filteredResults].sort(
      (a, b) => a.metrics.latency - b.metrics.latency
    );
    const requestsRank = [...filteredResults].sort(
      (a, b) => b.metrics.requestsPerSecond - a.metrics.requestsPerSecond
    );
    const bytesRank = [...filteredResults].sort(
      (a, b) => b.metrics.bytesPerSecond - a.metrics.bytesPerSecond
    );

    const getRank = (array: Result[], result: Result) =>
      array.findIndex((item) => item.testCase.name === result.testCase.name) +
      1;

    return filteredResults.map((result) => ({
      name: result.testCase.name,
      latencyRank: getRank(latencyRank, result),
      requestsRank: getRank(requestsRank, result),
      bytesRank: getRank(bytesRank, result),
    }));
  }, [filteredResults]);

  // Function to display rank with indicator
  const getRankLabel = (rank: number) => {
    if (rank === 1) return "ðŸ¥‡ ";
    if (rank === 2) return "ðŸ¥ˆ ";
    if (rank === 3) return "ðŸ¥‰ ";
    return `#${rank} `;
  };

  // Calculate comparison ratios relative to the selected framework
  const getComparisonRatio = (
    value: number,
    referenceValue: number,
    higherIsBetter: boolean
  ): string => {
    if (!selectedFramework) return "";

    // Ignore selected row
    if (value === referenceValue) return "";

    // Calculate ratio between values
    let ratio: number;
    let isImprovement: boolean;

    if (higherIsBetter) {
      ratio = value / referenceValue;
      isImprovement = value > referenceValue;
    } else {
      ratio = referenceValue / value;
      isImprovement = value < referenceValue;
    }

    // Format the ratio with + for improvements, - for regressions
    const formattedRatio = ratio.toFixed(1);
    return isImprovement ? `+${formattedRatio}x` : `-${formattedRatio}x`;
  };

  return (
    <main>
      <div className="container">
        <h1>Performance Comparison</h1>

        <div className="tabs">
          {categories.map((category) => (
            <button
              key={category}
              className={`tab ${category === currentCategory ? "active" : ""}`}
              onClick={() => setActiveCategory(category)}
            >
              {category}
            </button>
          ))}
        </div>

        <div className="metrics-comparison">
          <div className="sort-controls">
            <label>Sort by: </label>
            <select
              value={sortBy}
              onChange={(e) => setSortBy(e.target.value as SortMetric)}
            >
              <option value="requestsPerSecond">Requests/sec</option>
              <option value="latency">Latency</option>
              <option value="bytesPerSecond">Throughput</option>
            </select>
            {selectedFramework && (
              <button
                className="reset-selection"
                onClick={() => setSelectedFramework(null)}
              >
                Clear Selection
              </button>
            )}
          </div>

          <table>
            <thead>
              <tr>
                <th>Framework</th>
                <th>Latency (ms)</th>
                <th>Requests/sec</th>
                <th>Throughput (MB/sec)</th>
              </tr>
            </thead>
            <tbody>
              {filteredResults.map((result: Result, index: number) => {
                const ranking = rankings.find(
                  (r) => r.name === result.testCase.name
                )!;

                // Find reference values if a framework is selected
                const selectedResult = selectedFramework
                  ? filteredResults.find(
                      (r) => r.testCase.name === selectedFramework
                    )
                  : null;

                const latencyRatio = selectedResult
                  ? getComparisonRatio(
                      result.metrics.latency,
                      selectedResult.metrics.latency,
                      false
                    )
                  : "";

                const requestsRatio = selectedResult
                  ? getComparisonRatio(
                      result.metrics.requestsPerSecond,
                      selectedResult.metrics.requestsPerSecond,
                      true
                    )
                  : "";

                const bytesRatio = selectedResult
                  ? getComparisonRatio(
                      result.metrics.bytesPerSecond,
                      selectedResult.metrics.bytesPerSecond,
                      true
                    )
                  : "";

                return (
                  <tr
                    key={index}
                    className={
                      result.testCase.name === selectedFramework
                        ? "selected"
                        : ""
                    }
                    onClick={() => setSelectedFramework(result.testCase.name)}
                  >
                    <td>{result.testCase.name}</td>
                    <td>
                      {getRankLabel(ranking.latencyRank)}
                      {result.metrics.latency}
                      {latencyRatio && (
                        <span
                          className={`ratio ${
                            latencyRatio.startsWith("+")
                              ? "positive"
                              : "negative"
                          }`}
                        >
                          {latencyRatio}
                        </span>
                      )}
                    </td>
                    <td>
                      {getRankLabel(ranking.requestsRank)}
                      {result.metrics.requestsPerSecond.toLocaleString()}
                      {requestsRatio && (
                        <span
                          className={`ratio ${
                            requestsRatio.startsWith("+")
                              ? "positive"
                              : "negative"
                          }`}
                        >
                          {requestsRatio}
                        </span>
                      )}
                    </td>
                    <td>
                      {getRankLabel(ranking.bytesRank)}
                      {(result.metrics.bytesPerSecond / 1024 / 1024).toFixed(2)}
                      {bytesRatio && (
                        <span
                          className={`ratio ${
                            bytesRatio.startsWith("+") ? "positive" : "negative"
                          }`}
                        >
                          {bytesRatio}
                        </span>
                      )}
                    </td>
                  </tr>
                );
              })}
            </tbody>
          </table>

          <div className="table-info">
            {selectedFramework ? (
              <p>
                Current selection: <strong>{selectedFramework}</strong>. Click
                on another framework to see the difference.
              </p>
            ) : (
              <p>
                <i className="clickable-hint">
                  ðŸ‘† Click on any framework to select it as a reference for
                  comparison
                </i>
              </p>
            )}
          </div>
        </div>
      </div>
    </main>
  );
}

export default App;
